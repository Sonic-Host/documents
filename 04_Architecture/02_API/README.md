# API 処理のアーキテクチャ定義書

本章では、バックエンドアプリの API 処理にフォーカスしたアーキテクチャ定義を記載する。

## アプリ言語・フレームワークの選定

### 言語

開発言語としては[Node.js](https://nodejs.org/ja/)を使用する。  
理由としては、

- フロントエンドの開発言語と平仄を合わせられること
- Lambda との相性として性能が悪くないため
- Express という幅広く利用されているフレームワークを Lambda で利用できるため

### フレームワーク

開発言語のフレームワークとしては[Express](https://expressjs.com/ja/)を利用する。  
理由としては、

- Node.js の中で一番有名なフレームワークであり、Tips 記事がたくさんある
- Filter 処理などが簡単に実装でき、共通化による開発の効率化が望みやすい

## 静的チェック方式の確定

コードの静的チェックとしては[ESLint](https://eslint.org/)を利用する。  
Eslint は JS で一般的に利用される、静的チェックツールであり、コーディングの規約が適用されているかどうかのチェックをシステム上で実現することが可能になる。  
また、フォーマッター（整形）については[prettier](https://prettier.io/)を利用する。

型定義の確認については[TypeScript](https://www.typescriptlang.org/)を利用する。

## テスト方式の確定

### 単体テスト

テストとしては[jest](https://jestjs.io/ja/)を利用する。  
理由としては、

- Node.js のテストとして利用できるため
- フロント側のテストツールと平仄を合わせられるため

#### 確認観点

バックエンドアプリのテスト観点として以下のことを実施する。

- バリデーションチェックの確認
  - 入力項目についてセキュアかどうかを確認
    - https://ajv.js.org/security.html
- 正常系の応答の確認
- 業務エラーの確認
  - レスポンス内容の妥当性
  - ログ出力内容の妥当性
- データ参照結果の妥当性の確認
  - 検索結果なしの場合の挙動
  - 検索結果１つの場合の挙動
  - 検索結果複数の場合の挙動
- DB の状態

#### テスト実施方法

バックエンドアプリのテストの実行方法として以下を実施。

- DB はローカルで Docker を立ち上げて実施（モックを使用しない）
- ユーザの状態は用意されたパターンから選定して使用(jwt を渡す)
  - 未登録ユーザ
  - ユーザ情報のみ登録済みユーザ
  - サイト・決済情報を登録済みユーザ
  - サイト複数登録済みユーザ
- 関数単位ではなく、実際に API を打鍵してテストを実施

## バリデーション方式の統一

ここではバリデーションチェックの実現方式について記載する。  
バックエンドアプリのバリデーションチェック用フレームワークとしては[ajv](https://ajv.js.org/) を利用する。  
理由としては、

- Node.js/Typescript の環境においては性能的に優れているフレームワークのため
- バリデーション内容を直感的に指定ができるため。
- セキュリティ的に入力項目が安全なチェック項目になっているかの検証が可能なため。

### バリデーションチェックの検知方法

バリデーションチェック用の関数を作成し、スキーマ定義を渡すだけで勝手にバリデーションチェックを実施し、レスポンスを返すような関数にする。

### エラー通知のフォーマット

エラー通知のファーマっとについては、[全体システム方式のレスポンスパラメータ](../01_System/README.md#レスポンスパラメータ)を参照。

## 共通業務チェックルールの統一

バックエンド側で実施する共通業務チェックの内容を定義する。  
今のところ考慮するべきは、

- 認証チェック
- 削除・更新時のリソースチェック

### 認証情報のチェック

正しい認証情報でリクエストが来ているかどうかをチェックする。  
JWT 形式で渡ってくるため、JWT が正当なものかどうかをチェックする。  
なお、具体的なチェック内容は基盤側の方式設計書の方に記載する。（業務アプリ側でチェックはしない。）

### 削除・更新時の業務チェック

リクエスト時の HTTPMETHOD が PUT/DELETE の場合にはフロント側で認識しているリソース状況とバックエンド側で保持しているリソース状況が一致しているかを確認する必要がある。

リクエストボディの`current`の値を参照し、バックエンド側のリソースと一致しているかのチェックを行う。

## ログ処理方式の統一

本章ではどのようにログを出力するかを記載する。

### 共通的な値の管理方法

スレッド単位で管理するべき情報を定義する。  
今想定しているのは以下の情報をスレッドローカルで管理。

- ユーザ ID
- トランザクション ID

Node.js ではスレッドローカルという概念はないため、疑似的にスレッドローカルを作成するために、[async_hooks](https://nodejs.org/api/async_hooks.html#)を利用する。

#### ユーザ ID

ユーザ ID は JWT から抽出し、スレッドに入れる。

#### トランザクション ID

トランザクションＩＤについてはアプリとして処理する前にミドルウェア/基盤レイヤーで採番されたトランザクション ID を使用する。  
今のところ API-Gateway で採番されたトランザクションＩＤを使用する想定。

### API におけるログレベルの分け方

本章ではＡＰＩにおけるログレベルの分け方を定義する。

#### DEBUG

一番低い DEBUG ログは普段出力しない。  
エラーが発生した時にシステムの処理上ポイントとなる情報を収集するために使用する。

基本共通部品でのみ使用するログレベル。

#### INFO

エラーが発生した際や外部通チンした際など、エラーとして開発者に通知するほどではないが、ログとして残しておきたいときに使用する。  
INFO の場合はユーザ側で正しい情報や手順に従えば自然に回復できる。  
以下の条件の際にログとして出力される想定。

- 業務エラーが発生。
  - 発生する原因となった変数も一緒に出力
- 外部通信を実施。
  - リクエスト情報
  - レスポンス情報

#### WARN

エラーが発生した際に、特定のユーザのみが影響を受けている状態だと判断できる場合に使用する。  
ユーザ側のアクションで回復できない状態である。

#### ERROR

エラーが発生した際に、全ユーザが影響を受けている状態だと判断できる場合に使用する。  
ユーザ側のアクションで回復できない状態である。

## データ管理方式の統一

本章ではデータ管理の方法について記載する。

### トランザクション管理方法について

バックエンドのデータベースとしては DynamoDB のような KVS 型のデータベースを利用する。  
DynamoDB は RDBMS に機能として備わっているトランザクション機能はないため、独自で実装する必要がある。

#### データ更新のタイミング

データ更新のタイミングは API の処理が完了したタイミングで実施する。  
レスポンスのステータスによってデータの更新をするかしないかをハンドリングする。

| レスポンスステータス | データ更新有無 | 備考                                 |
| -------------------- | -------------- | ------------------------------------ |
| 200 ~ 399            | 有り           | 300 系も成功として扱う               |
| 400 ~                | 無し           | 400 以上は失敗のレスポンスとして扱う |

#### 更新情報の一時保管方法

API の最後の処理としてデータを更新するためには、更新情報を一時保管する必要がある。  
そのために、保管先としてスレッドローカルを使用する。

スレッドローカルに DB に変更するない用をスタックとして保持する。

#### データ更新時のチェック内容

データを更新する際に必ず現在フロント側で認識しているリソース状況と一致しているかどうかのチェックをする。  
チェックした結果不一致の場合にはエラー処理を実施。

### データの管理形式

ここではデータの管理方式について記載する。  
本プロジェクトでは様々なデータ項目を扱うが、項目ごとにどのように管理していくかを定義する。

#### データのメタ情報

データ項目を生成するたびに付随するメタデータを定義する。

##### ID の生成・登録について

ID とはデータ項目とを一意にするための識別子である。  
ID の生成方式には様々な方法があるが、以下の条件を満たす方法で生成する。

- 一意である
- スレッド間でロックしない
- 時間順で生成される

上記を満たすための寳保として Unix 時間 + ランダム数　を使用したＩＤ生成とする。

##### 生成日時・更新日時の管理

保守性を向上させるために、データの生成・更新時間を保管する。  
データのレコードが生成されるたびに以下のメタデータを付随させる。

- 生成日時（createdAt）： データが生成された時間
- 更新日時（updatedAt）： データが最後に更新された時間(最初は createdAt と同じ)

##### 削除日時の管理

テーブルに保管されたデータを削除する場合、最初の３日間は物理削除せず、論理削除にとどめる。  
そのために、以下のメタデータを各レコードに追加する。

- 削除日時（deleteAt）：　レコードから消される削除日時。

バックエンド側から検索・更新をかける際には必ず deleteAt に値が存在するレコードは対象外にするようにする。

## ディレクトリ構造

ディレクトリ構造について定義する。  
ディレクトリは基本的にコンポーネントベースの構造とする。  
※この章は実際にプロジェクトを組み立てて行く中で育てる。
