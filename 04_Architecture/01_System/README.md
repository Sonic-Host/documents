# システムアーキテクチャ

本資料は Sonic Host における全体のシステムアーキテクチャを定義する。  
API/クライアントアプリ/AWS 基盤とそれぞれ領域をまたがるような分野にフォーカスして定義を行うものとする。

## API のインターフェースの統一

本章では、API のインターフェースについて定義する。  
API のインターフェースを共通的に定義することにより、クライアントアプリの共通部品の処理でクライアント側の DB（React であれば Redux など）を自動で更新することができる。

![dataSync](images/dataSync.svg)

### URI

URI についてはリソースの置き場所を定義する。
つまり、リソースと URI は 1:1 の関係になる。  
Git に登録されている 01_Sequences のフォルダ第一階層単位で分けて Resource を分ける。  
バックエンド側の Lambda についてもマイクロサービスの分割単位としてこの階層単位で作成する。

![UriPattern](images/UriPattern.svg)

ルールとしては以下の通りである。

- 名詞で完結すること。getNotification のように動詞は入れない。
- ワード単位で/区切りを使用すること。siteDomain とする場合は site/domain のように管理すること。
- お知らせのようにリストで管理されているものは特定の項目を対象とする場合、パスパラメータを使用する。
  - ただし、ユーザ検索機能を利用した場合はクエリパラメータで表現する。

### メソッド

メソッドについては、URI で指定したリソースに対して、どのような操作を行うのかを定義する。  
英語でいうところの、目的語に対する動詞である。

種類としては以下のように定義する。
| メソッド | 操作内容　|
| ------- | --------- |
| GET | 取得 |
| POST | 追加 |
| PUT | 更新 |
| DELETE | 削除 |

上記のメソッドの種類によって、バックエンド側お呼び、クライアント側はリソースに対する処理の内容を動的に変更する。

なお、取得と追加を同時に行う場合。要はバックエンド側で発番されたリソースを直ちに取得したい場合には、POST を使用すること。

![](images/methodPattern.svg)

### ボディパラメータ

ボディパラメータは、データの項目を定義する。  
そうすることによって、メソッドの種類と合わせてクライアントとバックエンドのデータの更新の同期を取っていくことができる。

#### リクエストパラメータ

クライアントアプリ ⇒ バックエンドへの通信をリクエストと定義する。  
よって、ユーザがバックエンドに対してどのようなリソース項目の取得・更新・削除をしたいという要求があったかを伝える。

リクエストの内容例としては以下のようになる。

```json
{
 "data" : {...}, // 内容は各メソッドを参照
 "current" : {...} // 現在フロント側で認識しているリソース内容
}
```

##### GET

検索機能を利用した項目の検索の場合はクエリパラメータで指定する。

##### POST

POST の場合は以下のようにして指定する。

- どのような項目を追加したいか指定する場合は、data というパラメータに JSON 形式で指定する。
- 現在どのような値としてクライアントが認識しているか指定する場合は current というパラメータに JSON 形式で指定する。
  - POST で使用する場合は主にリスト管理されているデータの時に使用される。
- ID などの識別子を作成する場合は、バックエンド側で生成すためクライアント側では指定をしない。

##### PUT

PUT の場合は以下のようにして指定する。

- どのような項目を変更したいか指定する場合は、data というパラメータに JSON 形式で指定する。
- 現在どのような値としてクライアントが認識しているか指定する場合は、current というパラメータに指定する。
  - PUT の場合は data と必ず同じ項目をセットする必要あり。

##### DELETE

DELETE の場合は以下のようにして指定する。

- どのような項目を削除したいか指定する場合は、data というパラメータに JSON 形式で指定する。
  - DELETE の場合はレコードを特定するキーのみを入力する。
- 現在どのような値としてクライアントが認識しているかを指定する場合は、current というパラメータに指定する。
  - DELETE の場合は削除する想定のレコードを全部項目を入れる。

#### レスポンスパラメータ

リクエストの結果として帰ってきた通信(クライアント ⇐ バックエンド)をレスポンスとして定義する。  
よって、ユーザにバックエンド側でどのようなリソース項目の変更があったか・状態であるかを通知する。  
クライアント側では、レスポンスの結果に応じて Redux などのクライアント側のＤＢの情報を更新する。

##### 共通

ここでは、各メソッドにおいて共通となる項目について記載する。  
特にエラー時の応答についてはここで記載する。

レスポンスステータスについては以下のように定義する。
| ステータスコード | 定義 |
| --------------- | ---- |
| 200 | 成功 |
| 202 | 非同期処理の依頼成功 |
| 400 | バリデーションエラー・業務エラー |
| 403 | 認証エラー(トークン検証失敗) |
| 429 | 多重リクエストによる上限 |
| 500 | システムエラー |
| 503 | システムメンテナンス |

レスポンスの内容例としては以下のようになる。

```json
{
  "message" : { // 通知内容(ユーザに見せる内容)
    "type" : "success", // success, failure, modal
    "display": "ドメインの変更に成功しました。"
  },
  "error" : { // エラー内容
    "type" : "validation", // validation, buisiness, system
    "detail" : { // validation以外はstring形式
      "name" : "名前は２４文字以内で設定してください。"
    }
  },
  "data" : {...}, // リソース情報 any
  "requestKey" : 3, // 非同期処理のリクエストキー
}
```

レスポンスボディについては以下のように扱う。

- クライアント側で表示してほしいメッセージ情報については message という JSON で通知する。
  - type で成功・失敗・モーダルなどの種類を通知
  - display で表示するメッセージ内容を通知
- サーバー側で発生したエラー除法については error という JSON で通知する。
  - type でバリデーションエラー・業務エラー・システムエラーを通知
  - detail でエラーの詳細内容を通知
    - バリデーションエラーの場合は Form の name をキー名に、エラー内容をバリュー値で指定
- リソースの状態については data という JSON で通知する。
  - GET であればリソース全部
  - POST であれば追加されたリソース
    - リスト形式の物は追加されたリソースが１つでも配列形式の JSON で通知する。
  - PUT であれば変更されたリソース
  - DELETE であれば削除されたリソース
- 非同期の処理が依頼された場合は、requestKey というキー名で取引ＩＤを通知
  - 非同期の結果照会された場合には、処理結果として data という JSON でリソース状態を通知
  - 非同期の結果照会された場合には、処理結果の種類として type という JSON で通知
    - リソースの情報 URI は uri というキー名で通知
    - 非同期の処理のメソッドについては method というキー名で通知

##### GET

GET の場合は以下のようにして指定する。

- バックエンド側のリソースの情報は data という JSON で通知する。
  - GET は対象リソースの全情報が返却される

##### POST

POST の場合は以下のように指定する。

- バックエンド側で追加された情報は data という JSON で通知する。
  - POST は追加された情報のみを通知する
  - リスト形式の物は追加されたリソースが１つであっても配列形式の JSON で通知する。

##### PUT

PUT の場合は以下のように指定する。

- バックエンド側で変更された情報は data という JSON で通知する。
  - PUT は変更されたリソースのみを通知する。
  - リストの場合、どのリソースかわかるように key というキー名で一意に特定する情報を通知する。

##### DELETE

DELETE の場合は以下のように指定する。

- バックエンド側で削除された情報は data という JSON で通知する。
  - DELETE は削除されたリソースのみを通知する
  - リストの場合、どのリソースか分かるように key というキー名で一意に特定する情報を通知する。

## 認証方式の統一

ここではどのように認証を扱うかを定義する。  
認証はクライアント・基盤・アプリ全てにつながる内容である。  
認証方式を統一することで、ユーザ情報の扱い方などが確定やクライアントアプリ・AWS 基盤の認証方式が確定できる。

### 認証方式

認証方式としては OIDC を使用する。

### シーケンス

OIDC として認証・認可によるトークン情報の発行とリフレッシュトークンによるトークン情報の更新がある。  
それぞれについて、以降で記載するシーケンスに従う形で実施する。

#### 認証認可フロー

![oauthFlow](plantuml/oauthFlow.svg)

#### リフレッシュトークンフロー

![refreshFlow](plantuml/refreshFlow.svg)

### 取り扱うデータ

ユーザに直接的にかかわる個人情報については認証基盤側で持つ方針とする。  
Sonic Host では取り扱う情報は少ないため、以下のようになる。

| データ種類     | 使用するタイミング |
| -------------- | ------------------ |
| メールアドレス | ログインするとき   |
| パスワード     | ログインするとき   |

## データ管理個所の確定

ここではどのようにしてデータを管理するかを定義する。  
データ管理個所の確定をすることで、データ情報を追加するときに、どこに追加すればよいか決められる。  
様々なデータが存在するが、ここではバックエンド側で保持しているリソースについてのみを記載する。

### ユーザ情報

ユーザについては認可サーバで発行された ID トークン(JWT)にて管理する。  
そのため、ユーザ ID は認可サーバにて自動的に発行されたＩＤをそのまま使用する。

sonic-host で使用する情報は以下のようになる。
| 物理名 | 論理名 | 用途 |
| ------ | ----- | ---- |
| sub | ユーザ識別子 | リソースとユーザの紐づけなど。|
| email | メールアドレス | ユーザ管理のため。 |

### サイト情報に関するリソース

サイト情報に関するリソースはバックエンド側で NoSQL で管理する想定。  
API の IF を通すことにより、リクエストからクライアントのリソース変更依頼とレスポンスのリソース変更結果をお互いに通知する。  
API の IF を通すことにより、バックエンド側の DB とクライアント側の DB の同期を取る。

#### ユニーク ID

リソースにユニーク ID を付与する場合は、バックエンド側で自動的に発番する。  
よって POST でリソースを新たに追加する場合にはクライアント側でユニーク ID を発番する必要はない。

### 決済情報

クレカや決済した情報などについては Stripe で管理する。  
Stripe は Saas 型の決済プラットフォームであり、基本的に決済のルールも Stripe に従うものとする。

## ログ処理方式の統一

ここではどのようにログを扱うかを定義する。  
全領域でログの出力方式を共通化することで Slack 通知する際にどのチャネルに出力するべきか、どのようなシステム処理を自動実行するべきかがハンドリングできるようになる。

ただし、API-GW のリクエスト・レスポンスログのように自動で出力されるログについては仕方ないものとする。

以下の図で「解析方法」で解析する際にフォーマットが統一されていることで、統一的な検知が可能になる。

![loggingArchitecture](images/loggingArchitecture.svg)

### 出力形式

Sonic Host で出力するログの形式としては以下のようにする。  
また、Slack 通知できる量に限度があるため、極力無駄な情報は省くようにする省くようにする。

#### テンプレート

ログ出力のテンプレートは以下のようにする。

```json
{
  "startTime": "YYYY-MM-DDTHH:mm:ss.Z", // 開始時間。
  "level": "ERROR", // DEBUG INFO WARN ERROR のいずれか。これをもとに緊急性を変える。
  "functionName": "xxxx", // ログ出力が発生した関数名
  "fileName": "yyyyy", // ログ出力が発生したファイル名
  "lineNumber": "6", // ログ出力が発生したファイルの行
  "columnNumber": "10", // ログ出力が発生したファイルの列
  "userId": "zzzzz", // ユーザID。ユーザが認識できない状態のときはnullが入る。
  "trackId": "ooooo", // トランザクションID。クライアント側では設定不要。
  "messages": ["message"], // 出力メッセージ内容。配列形式で行替えを実現。
  "callStack": ["callstack"] // エラーが発生した時のコールスタック情報。
}
```

### ログレベルの観点

のちに Slack 通知する際の基準となるため、ログレベルを設定するための観点も定義する。

#### DEBUG

Slack にも CloudWatch のログにも出力しないもの。  
ログ場にも基本的に現れないが、何かしたら調査したいときにデバッグモードを ON にしたら出るようになるログレベル。

例えば、DynamoDB へのクエリとして投げる情報の出力など、普段はログとして出すものではないが、調査時にほしくなるような情報を出力する。

基本的にはシステム共通部品のみ出す。

#### INFO

Slack 通知されないが、Cloudwatch のログ上には出力されるもの。  
ユーザに影響を与えないエラーや、外部通信など、これからエラーが起きたら障害復旧が必要になる場面などで使用される。

基本的には共通部品で出力される想定。

#### WARN

Slack にも、CloudWatch にも出力されるもの。  
特定のユーザのみが影響を受けている場合に使用される。（ユーザ全体ではない）。

本エラーを発砲する際には、どのくらいの対応期間の猶予が与えられるのかも出力する。  
どのレベルで、どの猶予になるのかは今後詰めていく。

#### ERROR

Slack にも、Cloudwatch にも出力されるもの。  
全ユーザにて影響を受ける場合に使用される。

このエラーが発生した際には直ちの対応が要求される。

### トランザクション ID

バックエンド側でログを出力するときに使用するトランザクション ID についてはリバースプロキシで自動で採番される ID を使用する。  
Sonic Host においては AWS Api-Gateway で自動採番される ID を使用する。

## 資材管理方針の統一

本プロジェクトでは[GitHub](https://github.com/Sonic-Host)でプロジェクト用の資材を管理していく。

### ブランチ戦略

ブランチに関しては以下の法則を適用して、作成していく。

| ブランチ名   | 用途　       | 備考                                                                |
| ------------ | ------------ | ------------------------------------------------------------------- |
| main         | 本番資材     | 直接的に変更を加える、管理者以外がマージは不可                      |
| develop      | 本番移行前   | main に行く前にの資材。ここへのマージで STAG 環境にデプロイされる。 |
| feature/xxxx | 機能開発資材 | 開発中のブランチ。バンバン develop -> main にマージしたい。         |

#### コメント

※Ｇｉｔのコメントの種類によって CICD を回したりしたい。  
ここは要相談。そうすると commit lint とかも必要？

## CICD

ここでは CICD でどのように管理していくかを定義していく。
基本的には CICD で管理できるものは全部 CICD で管理していく想定。

対象のリポジトリは本番システムとして稼働するプロジェクトのみ。  
この README が管理されているプロジェクトのように資料を管理するプロジェクトであったり、ツールを管理するプロジェクトでは適用されない。

### 項目

テスト/デプロイとしてどのようなことを各プロジェクトごとに実施していくかを定義していく。  
テスト/デプロイとしては、以下のことをそれぞれ実施する。

| タイトル           | テスト内容                                                                                        | 備考 |
| ------------------ | ------------------------------------------------------------------------------------------------- | ---- |
| Lint               | ソースコードの静的チェック。<br>EsLint 等で適用したルール通りにソースが書かれたかをチェックする。 |      |
| SAST               | SAST ツールによるソースのセキュリティチェック。                                                   |      |
| ライブラリチェック | ライブラリのバージョンをチェック。<br> 脆弱性ありだったら、プルリクを自動で作成。                 |      |
| test               | UT テストを実施する。<br> E2E テストは develop/main にマージした際に実行する                      |
| deploy             | デプロイを実行する。<br>develop であればテスト環境 main であれば本番環境にデプロイ                |

## テスト方針の統一

ここではテストで確認する共通的な観点を定義する。  
各プロジェクトにおいては、本章にて記載の内容をテスト観点として盛り込む必要がある。

### テストコードの書き方

ここではテストコードの可読性を高めるための観点を記載する。

- テストコードの説明として以下の段階に分けて説明を記載。
  - 画面名/機能名の日本語説明
  - 事前状態の記載（ユーザ・データの状態）
  - 実施内容の記載（どういう操作をして、どういう結果になるのか）
  - どの項目が、どういう値になるのか、（この説明の中で検証を実施する。jest の it のようなもの）
- モックはなるべく使用しない
- テスト単位は関数毎などにしないでなるべく機能テストとして実施するべき

### 単体で確認すること

単体テストとしては以下の観点を確認すること。

- 命令網羅で確認
- カバレッジは 80%以上
  - カバレッジに含めなくていい処理は実施が局所的な例外処理など、実運用において滅多に動かない処理に限定
- 境界値の確認
- セキュリティの確認（基盤レイヤーで守られてないセキュリティの確認）
  - サニタイズの確認
  - ＣＯＲＳの確認

### 結合テストで確認すること

結合テストとしては以下の観点を確認すること。

- ユーザの状態ごとに確認すること。
  - 未登録ユーザ
  - ユーザ情報のみ登録済みユーザ
  - サイト・決済情報含めて登録済みユーザ
  - 複数サイト登録済みユーザ
- シーケンスのパターンごとに確認すること
- 外部サーバー以外のモックは使用せずに確認する事
- 性能の確認
  - API の性能確認
    - 並列実行されてデータ不整合が起きないかの確認がメイン(複数ユーザでそれぞれ API を打鍵するイメージ)
    - スロットリングの確認

## セキュリティ方針の確定

セキュリティの方針を記載する。

- 〇〇のセキュリティ要件に従っていること
- 認証はトークン認証方式を採用する
- ユーザ情報は Cognito などの認証基盤で保持すること
- 顧客情報など外部に公開されてない情報は暗号化されて保管されること

## 性能要件の確定

- 基盤はサーバレスを採用することで、性能に関してはユーザの使用状況より弾性的に変更する
- API の使用量など性能項目については常時システムより監視を実施し、以下の基準にに達した場合は Slack アラームで通知する。
  - 想定上限の 75%を５分以上で INFO 通知
  - 想定上限の 85%を５分以上で WARN 通知
  - 想定上限の 90%で ERROR 通知
